\documentclass[pdf] {beamer}
\mode<presentation>{}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

\usetheme{Copenhagen}

\newcommand{\SAT}{\textnormal{$k$-SAT}}
\newcommand{\SATbf}{\textbf{$k$-SAT}}
\newcommand{\CNF}{\textnormal{$k$-CNF}}
\newcommand{\vbl}[1]{\textnormal{vbl(#1)}}
\newcommand{\dist}[2]{d_H(#1,#2)}
\newcommand{\ball}[2]{B_{#1}(#2)}
\newcommand{\ballk}[2]{B^k_{#1}(#2)}
\newcommand{\astar}{\alpha^*}
\newcommand{\PBS}{\textnormal{Promise-Ball-$\SAT$}}
\newcommand{\PBSbf}{\textbf{Promise-Ball-$\SATbf$}}
\newcommand{\cc}{\mathcal{C}}
\newcommand{\bits}{\{0,1\}}
\newcommand{\kbits}{\{1,...,k\}}
\newcommand{\poly}{\textnormal{poly}}
\renewcommand{\Pr}{\textnormal{Pr}}
\renewcommand{\O}{\mathcal{O}^*}



%% preamble
\title{Derandomization of Schoning's Algorithm}
\subtitle{CS5330 Presentation}
\author{Li Zeyong, Eldon Chung}
\begin{document}

%% title frame 
\begin{frame}
	\titlepage
	
\end{frame}

\begin{frame}{Outline}
	\tableofcontents
\end{frame}

\section{Introduction and Motivation to k-SAT}
	\begin{frame}{Introduction}
	
	\end{frame}
	\begin{frame}{Motivation}
	
	\end{frame}
	\begin{frame}{Problem statement}
	
	\end{frame}

\section{Sch\"{o}ning's randomized algorithm}
	\begin{frame}{Introduction}
		
	\end{frame}
	\begin{frame}{Algorithm description}
		\begin{algorithm}[H]
			\caption{$\PBS$-Random-Walk}
			\DontPrintSemicolon
			\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
			\Input{$(F,\alpha,r)$}
			\Output{A satisfying assignment $\astar$ or NO if no $\astar$ are found}
			\BlankLine
			\For{steps = 1 to 3n}{
				\lIf{$\alpha$ satisfies $F$}{return $\alpha$}
				Choose an arbitrary clause $C$ not satified by $\alpha$\\
				Choose a literal in $C$ uniformly at random and flip its value in $\alpha$
			}
			\lIf{$\alpha$ satisfies $F$}{return $\alpha$}
			\hspace{7em}\lElse{return NO}
			\end{algorithm}
	\end{frame}
	\begin{frame}{Analysis}
		Just like in the case of 2-SAT, we would like to model the process as a random walk, where a state denotes the Hamming distance of the current assignment $\alpha$ from the actual satisfying assignment $\alpha^*$. \\~\
		
		At every step, the algorithm goes closer to $\alpha^*$ with probability of at least $\frac{1}{k}$, and with probability at most $1 - \frac{1}{k}$ it moves further away. \\~\
		
		Why? if there was a satisfying assignment, surely at least one of the literals has to be satisfied! And since there are $k$ literals, with probability at least $\frac{1}{k}$ we choose it. \\~\
	\end{frame}
	\begin{frame}{Analysis}
		\begin{theorem}
			(Proof Omitted) For an assignment $\alpha$ within some Hamming Distance $d$ away from a satisfying assignment $\alpha^*$, the algorithm finds $\alpha^*$ with probability $\geq (\frac{1}{k-1})^d$.
		\end{theorem}
		This actually follows from a detailed analysis of the previously mentioned random walk. 
	\end{frame}
	
\section{Basic Derandomization with Local Search}
	\begin{frame}{Derandomizing the algorithm}
		\begin{enumerate}
		\item The choice of an initial assignment $\alpha$
		\item The random walk around the initial assignment.
		\end{enumerate}
	\end{frame}
	\begin{frame}{Idea}
		We can view the randomized algorithm as searching for the satisfying assignment within a certain radius.
		\begin{definition}[Hamming Ball]
			$B_r(\alpha)$ is called a Hamming Ball, which is the set of all assignments which have a Hamming Distance of at most $r$ from $\alpha$.\\
		\end{definition}
	\end{frame}		
	\begin{frame}
		We can traverse the Hamming Ball through a recursive method as follows:
		\begin{algorithm}[H]
			\caption{$\PBS$-Recursion}
			\DontPrintSemicolon
			\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
			\Input{$(F,\alpha,r)$}
			\Output{A satisfying assignment $\astar$ or NO if no $\astar$ are found}
			\BlankLine
			\lIf{$\alpha$ satisfies $F$}{return $\alpha$}
			\hspace{7em}\lElseIf{r = 0}{return NO}
			Choose an arbitrary clause $C$ not satified by $\alpha$\\
			\ForEach{literal $l \in C$}{
				$\alpha'$ = $\PBS$-Recursion($F^{[l = 1]}, \alpha^{[l=1]},r-1)$\\
				\lIf {$\alpha'$ satisfies $F$}{Return $\alpha'$}
			}
			{return NO}
		\end{algorithm}		
	\end{frame}
	\begin{frame}
\begin{lemma}
			$\PBS \textnormal{-Recursion}$ solves $\PBS$ in $\O(k^r)$ time.
		\end{lemma}
		\begin{proof}
			The running time is straightforward. Each clause has at most $k$ literals and hence each node in the recursion tree has at most $k$ branches. The depth of the recursion three is at most $r$. Hence, there are at most $k^r$ leaves in the recursion tree. The overall runtime is $\O(k^r)$. \par 
		\end{proof}
	\end{frame}
	\subsection{Covering Codes}
	\begin{frame}
		Idea: since we have a space of possible assignments, and our search is a set of assignments of some Hamming distance away, we can just try to cover the entire space with a few of these balls. \par
		\begin{definition}[Covering Code]
		A (binary) Covering Code of length $n$ and radius $r$, $\cc_r \subseteq \bits^n$ is defined as: $\forall \alpha \in \bits^n, \exists c \in \cc_r$ such that $\alpha \in \ball{r}{c}$. That is, the Hamming Balls of radius $r$ centered at each member of $\cc_r$ covers the set $\bits^n$.
\end{definition}
	\end{frame}
	\begin{frame}{Analysis of the covering codes}
	
	\end{frame}
	\subsection{Derandomized Algorithm}
	\begin{frame}{Combining the two derandomizations}
	\begin{algorithm}[H]
	\caption{Deterministic $\SAT$}
	\DontPrintSemicolon
	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
	\Input{A $\CNF$ formula $F$ with $n$ variables}
	\Output{A satisfying assignment $\astar$ or NO if no $\astar$ are found}
	\BlankLine
	Initialization: Compute covering code $\cc_{\rho n}$\\
	\ForEach{code $c \in \cc_{\rho n}$}{
		$\astar$ = $\PBS$-Recursion($F,c,\rho n$)\\
		\lIf{$\astar$ satisfies $F$}{return $\astar$}
	}
	{return NO}
\end{algorithm}
	\end{frame}


\section{Improving on the Derandomization}
	\begin{frame}{Aim}
	Overall running time: $\O((2(1-\frac{1}{k+1}))^n)$\\
	Notice that the parameter $k$ comes from the running time of $\PBS$-Recursion, which is $\O(k^r)$.\\
	If we could improve it to $\O((k-1)^r)$, then we achieve the desired $\O((2(1-\frac{1}{k}))^n)$ performance.
	\end{frame}
	\begin{frame}{Intuition}
	Observation 1: Whenever we fix an assignment for a variable, all clauses containing the variable would have one less literal to be considered. e.g.
	\begin{align*}
	&(x_1 \lor x_2 \lor x_3) \land (\bar{x_1} \lor x_4 \lor x_5)\\
	&\text{assigning }x_1 = 1\\
	&(1 \lor x_2 \lor x_3) \land (0 \lor x_4 \lor x_5)\\
	&(x_4 \lor x_5)
	\end{align*}
	\end{frame}	
	\begin{frame}{Intuition}
	Observation 2: We can cover a large Hamming Ball with smaller Hamming Balls. \\~\
	To achieve observation 2, we need to modify our Covering Codes to do a little more.
	\end{frame}	
	\subsection{Extended Covering Codes}
	\begin{frame}{Introduction}
	We define a $k$-ary Covering Code to be analogous to the previous Covering Code but instead of from $\{0,1\}^t$, we define it to be from $\{1,...,k\}^t$ instead. \\~\
	Now each point has $t$ coordinates and each coordinate takes the value from $1$ to $k$. The notion of distance remains as the number of coordinates in which the two points disagree on.\\
	$w_1 = \{1, 1, 1\}$ $w_2 = \{1, 3, 3\}$ \\
	$\dist{w_1}{w_2} = 2$ as there are two different coordinates.
	\end{frame}
	\begin{frame}{Size of the Covering Code}
	Let $V^k(r)$ denote the volume of a k-ary Hamming Ball of radius $r$. \\
	Number of points at whose distance is exactly $r$ from a particular point = $ {t \choose r}(k-1)^r$. Hence, $V^k(r) > {t \choose r}(k-1)^r$ \\
	By using a similar probabilistic argument as before, there exists a k-ary covering code $\cc_r^k$ such that 
	\begin{align*}
	|\cc^k_r| \leq \left \lceil \frac{t\ln(k)k^t}{{t \choose r}(k-1)^r} \right \rceil
	\end{align*}
	\end{frame}
	\begin{frame}{Size of the Covering Code}
	Lastly, by choosing $r = \frac{t}{k}$, and going through some algebra, we have the following bound:
	\begin{align*}
	|\cc^k_{{t/k}}| \leq \left \lceil \frac{t\ln(k)k^t}{{t \choose t/k}(k-1)^{t/k}} \right \rceil \leq \frac{t^2 k^t (k-1)^{(k-1)t/k}}{k^t(k-1)^{t/k}} \leq t^2(k-1)^{t-2t/k}
	\end{align*}
	\end{frame}
	\subsection{Improved Derandomized Algorithm}
	\begin{frame}{Algorithm}
	Before doing anything else, first compute a $k$-ary covering code $\cc_r^k$ of radius $\frac{t}{k}$, where $t$ is some constant. \\~\
	
	Upon the input of some $\CNF$ and a assignment $\alpha$, the algorithm greedily find the maximal independent set of unsatisfied clauses $G = \{C_1, C_2, ...,C_m\}$. \\
	\begin{enumerate}
		\item[1] Independent: any two clauses do not share any variables\\
		\item[2] Maximal: all other unsatisfied clauses (outside of $G$) share at least one variable with some $C_i$.
	\end{enumerate}
	Now we can break the problem instance into 2 cases: \\~\
	\end{frame}
	\begin{frame}
		\begin{enumerate}
			\item[1] $|G| \leq t$ : Enumerate all possible assignments for $G$ and run $\PBS$-Recursion on the new formula. \\~\
			Notice that all other unsatisfied clauses share at least one variable with $G$ which is now assigned a value. \\~\
			From observation 1, all unsatisfied clauses now have at most $k-1$ literals and the running time is $\O((k-1)^r)$.
		\end{enumerate}
	\end{frame}	
	\begin{frame}
		\begin{enumerate}
			\item[2] $|G| > t$: Arbitrarily choose a set $H \subseteq G$ such that $H$ is of size $t$. Now apply the k-ary covering code in the following manner: for each point $w \in \cc_r^k$, for the $i$th clause in $H$, let $p$ be the $i$th coordinate of $w$ and flip the value of the $p$th literal in the $i$th clause. Then recurse with $r' = r - (t - 2t/k)$\\~\
			
			For example, given $H = \{(x_1 \lor x_2 \lor x_3), (x_4 \lor x_5 \lor x_6)\}$ where all variables have value $0$ and $c = (2,3)$. Then we will have a new assignment by changing $x_2 = 1$ and $x_6 = 1$.
		\end{enumerate}
	\end{frame}	
	\begin{frame}
		What are we doing here?\\~\
		
		Let $\alpha[w]$ denote the assignment after flipping $t$ literals according to $w$. \\
		Suppose $w^*$ denotes the difference between assignment $\alpha$ and a satisfying assignment $\astar$ for the $t$ clauses in $H$. That is, we make $t$ correct moves towards $\astar$, $\dist{\alpha[w^*]}{\astar} \leq r - t$. \\
		We know $\exists w \in \cc_r^k$ such that $\dist{w}{w^*} \leq t/k$. Hence, the assignment $\alpha[w]$ makes at least $t - t/k$ correct moves and at most $t/k$ wrong moves.\\
		 We have $\dist{\alpha[w]}{\astar} \leq r - (t - t/k) + t/k \leq r - (t-2t/k)$
	\end{frame}
	\begin{frame}
		Lastly, let us look at the running time. Let $\delta = t - 2t/k$. The recursion tree has $|\cc_r^k|$ branches and $r$ decreases by $\delta$ in each step. Hence, the height is ${r/\delta}$. The number of leaves is at most
		\begin{align*}
		|\mathcal{C}_r^k|^{r/\delta} &\leq (t^{2}(k-1)^{\delta})^{r/\delta}\\
		&= ((k-1)t^{2/\delta})^{r}
		\end{align*}
		Note that $t$ is independent of the input size and the running time is thus $\O((k-1)^r)$.
	\end{frame}
	\begin{frame}
	Questions?
\end{frame}
\end{document}